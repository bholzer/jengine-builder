var __ = require('underscore');
var arrays, basicObjects, deepClone, deepExtend, deepExtendCouple, isBasicObject,
  __slice = [].slice;

deepClone = function(obj) {
  var func, isArr;
  if (!__.isObject(obj) || __.isFunction(obj)) {return obj; }
  if (__.isDate(obj)) {return new Date(obj.getTime()); }
  if (__.isRegExp(obj)) {return new RegExp(obj.source, obj.toString().replace(/.*\//, "")); }
  isArr = __.isArray(obj || __.isArguments(obj)); func = function(memo, value, key) {if (isArr) {
      memo.push(deepClone(value));
    } else {
      memo[key] = deepClone(value);
    }
    return memo;
  };
  return __.reduce(obj, func, isArr ? [] : {}); };
isBasicObject = function(object) {
  return (object.prototype === {}.prototype || object.prototype === Object.prototype) && __.isObject(object) && !__.isArray(object) && !__.isFunction(object) && !__.isDate(object) && !__.isRegExp(object) && !__.isArguments(object); };
basicObjects = function(object) {
  return __.filter(__.keys(object), function(key) {return isBasicObject(object[key]); });
};

arrays = function(object) {
  return __.filter(__.keys(object), function(key) {return __.isArray(object[key]); }); };

deepExtendCouple = function(destination, source, maxDepth) {
  var combine, recurse, sharedArrayKey, sharedArrayKeys, sharedObjectKey, sharedObjectKeys, _i, _j, _len, _len1; if (maxDepth == null) {maxDepth = 20;
  }
  if (maxDepth <= 0) {
    console.warn('_.deepExtend(): Maximum depth of recursion hit.');
    return __.extend(destination, source);
  }
  sharedObjectKeys = __.intersection(basicObjects(destination), basicObjects(source));
  recurse = function(key) {
    return source[key] = deepExtendCouple(destination[key], source[key], maxDepth - 1);
  };
  for (_i = 0, _len = sharedObjectKeys.length; _i < _len; _i++) {
    sharedObjectKey = sharedObjectKeys[_i];
    recurse(sharedObjectKey);
  }
  sharedArrayKeys = __.intersection(arrays(destination), arrays(source));
  combine = function(key) {
    return source[key] = __.union(destination[key], source[key]);
  };
  for (_j = 0, _len1 = sharedArrayKeys.length; _j < _len1; _j++) {
    sharedArrayKey = sharedArrayKeys[_j];
    combine(sharedArrayKey);
  }
  return __.extend(destination, source);
};

deepExtend = function() {
  var finalObj, maxDepth, objects, _i;
  objects = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), maxDepth = arguments[_i++];
  if (!__.isNumber(maxDepth)) {
    objects.push(maxDepth);
    maxDepth = 20;
  }
  if (objects.length <= 1) {
    return objects[0];
  }
  if (maxDepth <= 0) {
    return __.extend.apply(this, objects);
  }
  finalObj = objects.shift();
  while (objects.length > 0) {
    finalObj = deepExtendCouple(finalObj, deepClone(objects.shift()), maxDepth);
  }
  return finalObj;
};

module.exports = {
  deepClone: deepClone,
  isBasicObject: isBasicObject,
  basicObjects: basicObjects,
  arrays: arrays,
  deepExtend: deepExtend
};